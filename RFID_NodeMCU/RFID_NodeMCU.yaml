# ESPHome configuration for NFC Reader with PN532 and NodeMCU
#

substitutions:
  name: nfc-reader
  friendly_name: nfc-reader
  http_endpoint: "http://10.42.0.1:8000/process/?card_id="

globals:
  - id: url
    type: std::string

esphome:
  name: ${name}
  friendly_name: ${friendly_name}
  on_boot:
    priority: -10
    then:
    - wait_until:
        wifi.connected:
    # - logger.log: API is connected!
    - rtttl.play: "success:d=24,o=5,b=100:c,g,b"
    - light.turn_on:
        id: activity_led
        brightness: 100%
        red: 0%
        green: 0%
        blue: 100%
        flash_length: 500ms

esp8266:
  board: d1_mini
  # framework:
  #   version: 3.0.2

# Enable logging
logger:
  level: INFO

# Enable Home Assistant API
api:
  encryption:
    key: !secret api_encryption_key
#   services:
#   - service: rfidreader_tag_ok
#     then:
#     - rtttl.play: "beep:d=16,o=5,b=100:b"

#   - service: rfidreader_tag_ko
#     then:
#     - rtttl.play: "beep:d=8,o=5,b=100:b"

#   - service: play_rtttl
#     variables:
#       song_str: string
#     then:
#     - rtttl.play: !lambda 'return song_str;'

ota:
  - platform: esphome
    password: !secret ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  min_auth_mode: WPA #WPA2


  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Nfc-Reader Fallback Hotspot"
    password: "Z144k7fG9esa"

captive_portal:

# button:
#   - platform: restart
#     name: "${friendly_name} Restart"
#     entity_category: config

i2c:
  scan: False
  frequency: 400kHz

http_request:
  esp8266_disable_ssl_support: True
  timeout: 
    seconds: 10

pn532_i2c:
  id: pn532_board
  on_tag:
    then:
    - light.turn_on:
            id: activity_led
            brightness: 100%
            red: 0%
            green: 0%
            blue: 100%
            flash_length: 500ms
    - lambda: |-
        ESP_LOGI("ndef", "Found Tag: %s", x.c_str());
    - http_request.get:
        capture_response: true
        # return endpoint + uid (and sanitize uid in c++)
        url: !lambda |-
          // Strip the dashes that the PN532 library adds to the UID string
          x.erase(std::remove(x.begin(), x.end(), '-'), x.end());
          // Convert the remaining hex string to a (long) decimal number
          long decimal_value = std::stol(x, nullptr, 16);
          // Build the final URL
          return std::string("${http_endpoint}") + std::to_string(decimal_value);
        on_response:
          then:
            - logger.log:
                level: INFO
                format: 'Response status: %d, Duration: %u ms'
                args:
                  - response->status_code
                  - response->duration_ms
            - if:
                # Check for "auth"/login response
                condition:
                  lambda: 'return body == "auth";'
                then:
                  # o=6 for higher pitch d=4 for shorter note b=100 for tempo
                  - rtttl.play: "two_short:d=4,o=6,b=100:16e6,16e6"
                  - light.turn_on:
                      id: activity_led
                      brightness: 100%
                      red: 0%
                      green: 100%
                      blue: 0%
                      flash_length: 1000ms
            - if:
                # Check for "logout" response
                condition:
                    lambda: 'return body == "logout";'
                then:
                  - rtttl.play: "long:d=3,o=4,b=100:6e6"
                  - light.turn_on:
                      id: activity_led
                      brightness: 100%
                      red: 0%
                      green: 100%
                      blue: 0%
                      flash_length: 1000ms
            - if:
                # Check for "registered" response
                condition:
                  lambda: 'return body == "registered successfully";'
                then:
                  - rtttl.play: "success:d=16,o=5,b=100:c6e6g6c7"
                  - light.turn_on:
                      id: activity_led
                      brightness: 100%
                      red: 0%
                      green: 0%
                      blue: 100%
                      flash_length: 1000ms
            - if:
                # Check for "profile saved" response
                condition:
                  lambda: 'return body == "profile saved";'
                then:
                  - light.turn_on:
                      id: activity_led
                      brightness: 100%
                      red: 0%
                      green: 0%
                      blue: 100%
                      flash_length: 1000ms
            - if:
                all:
                  - lambda: |-
                      return (body != "auth" &&
                              body != "logout" &&
                              body != "registered successfully" &&
                              body != "profile saved");
                then:
                  - logger.log:
                      format: "Error: Response status: %d, message %s"
                      level: WARN
                      args:
                        - response->status_code
                        - body.c_str()
                  - rtttl.play: "warning:d=12,o=5,b=100:c6p"
                  - light.turn_on:
                      id: activity_led
                      brightness: 100%
                      red: 100%
                      green: 0%
                      blue: 0%
                      flash_length: 1000ms
        on_error:
          then:
            - logger.log:
                format: "Request failed!"
                level: WARN
            - rtttl.play: "error:d=16,o=5,b=100:c6p"
            - light.turn_on:
                id: activity_led
                brightness: 100%
                red: 100%
                green: 0%
                blue: 0%
                flash_length: 1000ms

  # on_tag_removed:
    # then:
    # - homeassistant.event:
    #     event: esphome.tag_removed

# Define the buzzer output
output:
- platform: esp8266_pwm
  pin: D7
  id: buzzer

# binary_sensor:
#   - platform: status
#     name: "${friendly_name} Status"
#     entity_category: diagnostic

# Define buzzer as output for RTTTL
rtttl:
  output: buzzer

# Configure LED
light:
- platform: neopixelbus
  variant: WS2812
  pin: RX
  num_leds: 1
  flash_transition_length: 500ms
  type: GRB
  id: activity_led
  name: "${friendly_name} LED"
  restore_mode: ALWAYS_OFF